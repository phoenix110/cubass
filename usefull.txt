复合主键:
BaseGenericIdEntity
除了上面情况之外，如果需要将实体映射到具有复合主键的表，则直接继承 BaseGenericIdEntity 。在这种情况下，具体实体类必须有一个嵌入类型的字段代表复合主键，并使用 @EmbeddedId JPA 注解。


下面是关于在项目实体中继承基础实体的一些建议。
非持久化实体应该继承与持久化实体相同的基类。框架是根据实体所在注册文件：persistence.xml 或 metadata.xml 来确定实体是否是持久化实体。


除了上面情况之外，如果需要将实体映射到具有复合主键的表，则直接继承 BaseGenericIdEntity 。在这种情况下，具体实体类必须有一个嵌入类型的字段代表复合主键，并使用 @EmbeddedId JPA 注解。


如果要在中间件代码中使用 DataManager 时检查实体操作权限，请通过 DataManager.secure() 方法获取包装类并调用其方法。或者，可以设置 cuba.dataManagerChecksSecurityOnMiddleware 应用程序属性以打开整个应用程序的安全检查。


只有在将 cuba.entityAttributePermissionChecking 应用程序属性设置为 true 时，才会在中间件上强制执行属性权限。如果中间件为理论上可以被攻击的远程客户端提供服务，比如桌面客户端（这是可能的）。在这种情况下，还要将 cuba.keyForSecurityTokenEncryption 应用程序属性设置为唯一值。如果应用程序仅使用 Web 或 Portal 客户端，则可以安全地保留这些属性的默认值。



为了解决这个问题，平台包含一种在 SQL 级别上没有 distinct 的情况下正常运行的机制。此机制由 cuba.inMemoryDistinct 应用程序属性启用。启用后，会执行以下操作：

通过在属性值的开头添加加号来使这些属性成为_累加_属性。此符号表示在运行时从应用程序组件组装属性值。例如，cuba.persistenceConfig是一个累加属性。在项目中，指定了一个定义项目数据模型的 persistence.xml 文件。但是由于实际的属性值还包括应用程序所依赖的应用程序组件的 persistence.xml 文件，因此应用程序的完整数据模型还要包括组件中定义的实体。


上面集合中的最后一个文件是 local.app.properties。它可用于在部署时覆盖应用程序属性。如果该文件不存在，则会忽略该它。可以在应用程序服务器上创建此文件，在其中定义特定于该环境的所有属性。这样，配置信息将与应用程序分离，能够做到更新应用程序而不必担心丢失特定于环境的配置信息。生产环境使用 Tomcat部分包含使用 local.app.properties 文件的示例。



如果需要在事务提交成功之后做一些操作，可以使用 Spring 的 TransactionSynchronization 回调函数在事务完成之后执行任务。



*******事务***********
createTransaction() 方法创建一个新事务并返回 Transaction 接口。后续调用此接口的 commit() 、 commitRetaining() 、 end() 方法控制创建的事务。如果在创建时有另一个活动的事务，它将先暂停并在新创建的事务完成后恢复。

getTransaction() 方法要么创建新事务，要么附加到已有事务并返回一个嵌套事务。如果在调用时有一个活动的当前事务，那么该方法会成功完成，但后续调用嵌套事务的 commit()、 commitRetaining() 、 end() 方法对当前事务没有影响。但是，在没有调用嵌套事务的 commit() 方法的情况下调用 end() 方法，会将当前事务标记为 RollbackOnly。简单来说，就是只有嵌套事务成功提交了，外层事务才能提交。


Transaction 接口还有 execute() 方法接受 action 类或 lambda 表达式。action 类或 lambda 表达式表示的操作将在事务中执行。这样可以以函数式编程风格组织事务管理

UUID customerId = persistence.createTransaction().execute((EntityManager em) -> {
    Customer customer = metadata.create(Customer.class);
    customer.setName("ABC");
    em.persist(customer);
    return customer.getId();
});

Customer customer = persistence.createTransaction().execute(em ->
        em.find(Customer.class, customerId, "_local"));
需要注意，给定 Transaction 实例的 execute() 方法只能调用一次，因为事务在执行完操作代码后结束。

*******缓存***********
要启用实体缓存，请在 core 模块的 app.properties 文件中设置以下属性：
eclipselink.cache.shared.sales$Customer = true - 启用 sales$Customer 实体的缓存。
eclipselink.cache.size.sales$Customer = 500 - 将 sales$Customer 的缓存大小设置为 500 个实例。默认大小为 100。

*******文件存储***********
临时客户端级存储（ FileUploadingAPI ）将临时文件存储在由cuba.tempDir应用程序属性定义的文件夹中。如果出现任何故障，临时文件还是保留在文件夹中。cuba_FileUploading bean 的 clearTempDirectory() 方法由cuba-web-spring.xml文件中定义的定时任务周期性调用来清理临时存储。












































































































































































































































































































































































































